#!/usr/bin/env bash

# on défini un PATH orthodoxe par sécurité
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# on desactive les alias par sécurité
\unalias -a

# on glob pour le case
shopt -s extglob

_NAGIOS_STATUS_OK=0
_NAGIOS_STATUS_WARNING=1
_NAGIOS_STATUS_CRITICAL=2
_NAGIOS_STATUS_UNKNOWN=3

now=$(date +%s)

#solr_nodes="localhost mdp11"
#solr_port="8983"
#core_name="ecritel"


solr_nodes="$4"
core_name=$3
solr_port=$1
role_name=$2

local_host="localhost"

## on verifie que les dependances sont presentes ##
for MYPROG in curl grep ; do
        if ! type -ap $MYPROG &> /dev/null ; then
                echo "WARNING : impossible de trouver $MYPROG" ;
                exit $_NAGIOS_STATUS_UNKNOWN

        fi
done

HELP_STRING="Utilisation : ce script s'utilise avec arguments (voir les options).\n
 . Exemple d'utilisation : $(basename $0) 8983 master ecritel ""localhost mdp11"".\n
 . Options :\n
  \t. port : port utilisé par les services SOLR - une valeur numérique est attendue \n
  \t. rôle : rôle du serveur : "master" ou "slave" \n
  \t. coeur (core) : nom du "core" \n
  \t. host : spécifier ici le serveur cible de la réplication.\n"

# il faut que le sleep soit supérieur a la valeur ci-dessous (présente sur les noeuds slave)  : 
#<str name="pollInterval">${solr.replication.pollInterval:00:00:01}</str>

get_status() {

	# on vérifie que l'on obtient le status du core ecritel
	for host in $solr_nodes ; do	
		if ! curl "http://$host:$solr_port/solr/admin/cores?action=STATUS&core=$core_name" 2>&1 | grep -o uptime &> /dev/null ; then
			echo "Unable to obtain the $core_name core status from ${host}:$solr_port" ;
			exit $_NAGIOS_STATUS_CRITICAL
		fi
	done
}

create_key() {

	curl http://$local_host:$solr_port/solr/$core_name/update/"json?commit=true" -H "Content-type:application/json" -d '
		{		
		 "add": {"doc": {"id":"1","name":"ecritel_key","valeur":'"$now"'} }
		}' &> /dev/null

		# on attend 2s la replication
		sleep 2
}

read_key() {
	echo "$solr_nodes"

	# on verifie sur tous les serveurs
	for host in $solr_nodes ; do 
		timestamp=$(curl  -q http://$host:$solr_port/solr/$core_name/select"?q=id:1&wt=csv&indent=true&fl=valeur" 2>/dev/null  | grep -oE "([[:digit:]]{10})")
		if [ ! -z $timestamp ] ; then
			if (($timestamp != $now)) ; then
				echo "CRITICAL: $host don't have the right timestamp : $timestamp != $now" ;
				ERR_HOST+=($host)  ;
			fi
		else
			echo "CRITICAL: timestamp: "$timestamp" is empty" ;
			exit $_NAGIOS_STATUS_CRITICAL
		fi	
	done
	return ${#ERR_HOST[*]}
}

delete_key() {

	curl http://$local_host:$solr_port/solr/$core_name/update/json"?commit=true" -H "Content-type:application/json" -d '
		{
	 	"delete": {"query": "id:1" }
		}'
}

engine() {
	if ((${#ERR_HOST[*]} > 0)) ; then
		echo "CRITCAL: ${ERR_HOST[*]} is not up to date - getting $timestamp expected $now" ;
		exit $_NAGIOS_STATUS_CRITICAL
	else
		if [ "$1" == "slave" ] ; then
			echo "OK: node responding";
		fi
		if [ "$1" == "master" ] ; then
			echo "OK: all nodes are up to date" ;
		fi
		exit $_NAGIOS_STATUS_OK
	fi 
}

case $* in 
	help|-h|--help|"Aidez Moua Siou Plait"|\?)
		echo -e $HELP_STRING
		exit $_NAGIOS_STATUS_OK
	;;
	[0-9]*[:space:][a-z]*[:space:][a-z]*[:space:][a-z]*)
		
		echo "$solr_nodes"

		get_status $solr_port $role_name $core_name "$solr_nodes"

		create_key $solr_port $role_name $core_name 
	
		read_key $solr_port $role_name $core_name "$solr_nodes"
	
		delete_key $solr_port $role_name $core_name 

		engine $role_name
	;;
	status)
		if ! get_status	; then
			exit $_NAGIOS_STATUS_CRITICAL
		else
			echo "Service is available"  
			exit $_NAGIOS_STATUS_OK
	fi 
			
	;;
	[0-9]*)
		echo "Alpha Args are needed !!!"  
		exit $_NAGIOS_STATUS_WARNING
	;;
	[a-z]*)
		echo "Digit Args are needed !!!"  
		exit $_NAGIOS_STATUS_WARNING
	;;
	*)
		echo "Args are needed !!!"
		exit $_NAGIOS_STATUS_WARNING
	;; 

esac
